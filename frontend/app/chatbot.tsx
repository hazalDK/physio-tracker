import React, { useState, useEffect, useRef } from "react";
import {
  View,
  Text,
  Pressable,
  TextInput,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  SafeAreaView,
  Alert,
} from "react-native";
import Toast from "react-native-root-toast";
import { useNavigation } from "@react-navigation/native";
import { Ionicons } from "@expo/vector-icons";
import tw from "tailwind-react-native-classnames";
import * as SecureStore from "expo-secure-store";
import axios from "axios";

interface messageType {
  id: string;
  text: string;
  sender: string;
}

// Define message bubble components
const UserMessage = ({ message }: { message: string }) => (
  <View
    style={[
      tw`rounded-2xl rounded-br-none py-3 px-4 self-end max-w-3/4 mb-2`,
      { backgroundColor: "#14b8a6" },
    ]}
  >
    <Text style={tw`text-white`}>{message}</Text>
  </View>
);

const BotMessage = ({ message }: { message: string }) => (
  <View
    style={tw`bg-gray-200 rounded-2xl rounded-bl-none py-3 px-4 self-start max-w-3/4 mb-2`}
  >
    <Text style={tw`text-gray-800`}>{message}</Text>
  </View>
);

const DisclaimerMessage = () => (
  <View
    style={tw`bg-yellow-100 border border-yellow-300 rounded-lg py-2 px-3 self-start max-w-3/4 mb-4`}
  >
    <Text style={tw`text-yellow-800 text-xs font-medium`}>
      DISCLAIMER: This feedback is generated by AI and is not a substitute for
      professional medical advice. Always consult with your healthcare provider
      before starting, changing, or stopping any exercise program.
    </Text>
  </View>
);

export default function Chatbot() {
  const navigation = useNavigation();
  const [messages, setMessages] = useState([] as messageType[]);
  const [inputText, setInputText] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [userExercises, setUserExercises] = useState([]);
  const [recentPain, setRecentPain] = useState(0);
  const scrollViewRef = useRef<ScrollView | null>(null);

  // Fetch user exercise data when component mounts
  useEffect(() => {
    // Add initial bot message
    setMessages([
      {
        id: "welcome",
        text: "Welcome to your physiotherapy assistant! How can I help you today?",
        sender: "bot",
      },
      {
        id: "disclaimer",
        text: "DISCLAIMER",
        sender: "disclaimer",
      },
    ]);

    fetchUserData();
  }, []);

  const fetchUserData = async () => {
    try {
      let token = await SecureStore.getItemAsync("access_token");
      if (!token) {
        Alert.alert("Login Required", "Please sign in to continue", [
          { text: "OK", onPress: () => navigation.navigate("login" as never) },
        ]);
        return;
      }

      // Fetch active exercises
      // 2. Create an axios instance with proper defaults
      const api = axios.create({
        baseURL: process.env.API_URL || "http://192.168.68.111:8000",
        timeout: 10000,
        headers: { Authorization: `Bearer ${token}` },
      });

      // 3. Use Promise.all for parallel requests
      const [reportsResponse, exercisesResponse] = await Promise.all([
        api.get("/user-exercises/"),
        api.get("/reports/"),
      ]);

      setUserExercises(exercisesResponse.data);

      if (reportsResponse.data.length > 0) {
        setRecentPain(reportsResponse.data[0].pain_level);
      }
    } catch (error) {
      // 5. Handle token refresh
      if (axios.isAxiosError(error) && error.response?.status === 401) {
        try {
          // Attempt token refresh
          const refreshToken = await SecureStore.getItemAsync("refresh_token");
          if (!refreshToken) throw new Error("No refresh token available");

          const refreshUrl =
            process.env.API_URL || "http://192.168.68.111:8000";
          const refreshResponse = await axios.post(
            `${refreshUrl}/api/token/refresh/`,
            { refresh: refreshToken }
          );

          // Store new tokens
          const newToken = refreshResponse.data.access;
          const newRefreshToken = refreshResponse.data.refresh;

          await Promise.all([
            SecureStore.setItemAsync("access_token", newToken),
            SecureStore.setItemAsync("refresh_token", newRefreshToken),
          ]);

          // Retry both requests with new token
          const api = axios.create({
            baseURL: process.env.API_URL || "http://192.168.68.111:8000",
            timeout: 10000,
            headers: { Authorization: `Bearer ${newToken}` },
          });

          const [retryUserExercises, retryReports] = await Promise.all([
            api.get("/user-exercises/"),
            api.get("/users/active_exercises/"),
          ]);

          setRecentPain(retryReports.data[0]?.pain_level || 0);
          setUserExercises(retryUserExercises.data);
        } catch (refreshError) {
          console.error("Token refresh failed:", refreshError);

          // Clear tokens and redirect
          await Promise.all([
            SecureStore.deleteItemAsync("access_token"),
            SecureStore.deleteItemAsync("refresh_token"),
          ]);

          Alert.alert("Session Expired", "Please login again", [
            {
              text: "OK",
              onPress: () => navigation.navigate("login" as never),
            },
          ]);
        }
      } else {
        // Handle other errors
        console.error("API request failed:", error);
        Alert.alert(
          "Error",
          "Failed to load your exercises. Please check your connection and try again."
        );
        setRecentPain(0);
        setUserExercises([]);
      }
    }
  };

  const sendMessage = async () => {
    if (!inputText.trim()) return;

    // Add user message to the chat
    const userMessageId = Date.now().toString();
    setMessages((prevMessages) => [
      ...prevMessages,
      { id: userMessageId, text: inputText, sender: "user" },
    ]);

    // Clear input and show loading
    setInputText("");
    setIsLoading(true);

    try {
      let token = await SecureStore.getItemAsync("access_token");
      if (!token) {
        Alert.alert("Login Required", "Please sign in to continue", [
          { text: "OK", onPress: () => navigation.navigate("login" as never) },
        ]);
        return;
      }
      // Create context object with user's exercise data
      const exerciseContext = {
        exercises: userExercises,
        recentPain: recentPain,
        // Add any other relevant context from your models
      };

      const api = axios.create({
        baseURL: process.env.API_URL || "http://192.168.68.111:8000",
        timeout: 10000,
        headers: { Authorization: `Bearer ${token}` },
      });

      // Call your API endpoint that will communicate with OpenAI
      const response = await api.post("/api/chatbot/", {
        message: inputText,
        exerciseContext: JSON.stringify(exerciseContext),
      });

      // Add bot response to chat
      setMessages((prevMessages) => [
        ...prevMessages,
        {
          id: Date.now().toString(),
          text: response.data.message,
          sender: "bot",
        },
      ]);
    } catch (error) {
      console.error("Error sending message:", error);
      // Add error message
      // 5. Handle token refresh
      if (axios.isAxiosError(error) && error.response?.status === 401) {
        try {
          // Attempt token refresh
          const refreshToken = await SecureStore.getItemAsync("refresh_token");
          if (!refreshToken) throw new Error("No refresh token available");

          const refreshUrl =
            process.env.API_URL || "http://192.168.68.111:8000";
          const refreshResponse = await axios.post(
            `${refreshUrl}/api/token/refresh/`,
            { refresh: refreshToken }
          );

          // Store new tokens
          const newToken = refreshResponse.data.access;
          const newRefreshToken = refreshResponse.data.refresh;

          await Promise.all([
            SecureStore.setItemAsync("access_token", newToken),
            SecureStore.setItemAsync("refresh_token", newRefreshToken),
          ]);

          // Create context object with user's exercise data
          const exerciseContext = {
            exercises: userExercises,
            recentPain: recentPain,
            // Add any other relevant context from your models
          };

          // Retry both requests with new token
          const api = axios.create({
            baseURL: process.env.API_URL || "http://192.168.68.111:8000",
            headers: { Authorization: `Bearer ${newToken}` },
          });

          // Call your API endpoint that will communicate with OpenAI
          const response = await api.post("/api/chatbot/", {
            message: inputText,
            exerciseContext: JSON.stringify(exerciseContext),
          });

          setMessages((prevMessages) => [
            ...prevMessages,
            {
              id: Date.now().toString(),
              text: response.data.message,
              sender: "bot",
            },
          ]);
        } catch (refreshError) {
          console.error("Token refresh failed:", refreshError);

          // Clear tokens and redirect
          await Promise.all([
            SecureStore.deleteItemAsync("access_token"),
            SecureStore.deleteItemAsync("refresh_token"),
          ]);

          Alert.alert("Session Expired", "Please login again", [
            {
              text: "OK",
              onPress: () => navigation.navigate("login" as never),
            },
          ]);
        }
      } else {
        setMessages((prevMessages) => [
          ...prevMessages,
          {
            id: Date.now().toString(),
            text: "Sorry, I encountered an error. Please try again.",
            sender: "bot",
          },
        ]);
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleReset = async () => {
    try {
      let token = await SecureStore.getItemAsync("access_token");
      if (!token) throw new Error("No access token");

      await axios.post(
        (process.env.API_URL || "http://192.168.68.111:8000") +
          "/api/reset-chat/",
        {},
        { headers: { Authorization: `Bearer ${token}` } }
      );

      // Reset messages
      setMessages([
        {
          id: "welcome",
          text: "Welcome to your physiotherapy assistant! How can I help you today?",
          sender: "bot",
        },
        {
          id: "disclaimer",
          text: "DISCLAIMER",
          sender: "disclaimer",
        },
      ]);

      fetchUserData();

      // ðŸŽ‰ Show toast
      Toast.show("Chat reset!", {
        duration: Toast.durations.SHORT,
        position: Toast.positions.BOTTOM,
        backgroundColor: "#14b8a6",
        textColor: "white",
        shadow: true,
      });
    } catch (err) {
      console.error("Failed to reset chat:", err);
      Alert.alert("Error", "Could not reset chat.");
    }
  };

  return (
    <SafeAreaView style={tw`flex-1 bg-white`}>
      <KeyboardAvoidingView
        style={tw`flex-1`}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        {/* Header */}
        <View
          style={tw`flex-row items-center justify-between px-4 py-3 border-b border-gray-200`}
        >
          <Pressable
            onPress={() => navigation.goBack()}
            style={({ pressed }) => [
              tw`p-2 rounded-full`,
              { opacity: pressed ? 0.8 : 1 },
            ]}
          >
            <Ionicons name="arrow-back" size={24} color="#14b8a6" />
          </Pressable>

          <Text style={tw`text-lg font-semibold text-gray-800`}>
            Physio Assistant
          </Text>

          <Pressable
            onPress={handleReset}
            style={({ pressed }) => [
              tw`p-2 rounded-full`,
              { opacity: pressed ? 0.8 : 1 },
            ]}
          >
            <Ionicons name="refresh" size={24} color="#14b8a6" />
          </Pressable>
        </View>

        <ScrollView
          ref={scrollViewRef}
          style={tw`flex-1 px-4 pt-4`}
          contentContainerStyle={tw`pb-4`}
          onContentSizeChange={() =>
            scrollViewRef.current?.scrollToEnd({ animated: true })
          }
        >
          {messages.map((message) =>
            message.sender === "user" ? (
              <UserMessage key={message.id} message={message.text} />
            ) : message.sender === "disclaimer" ? (
              <DisclaimerMessage key={message.id} />
            ) : (
              <BotMessage key={message.id} message={message.text} />
            )
          )}

          {isLoading && (
            <View
              style={tw`self-start bg-gray-200 rounded-2xl rounded-bl-none py-3 px-4 mb-2`}
            >
              <ActivityIndicator size="small" color="#14b8a6" />
            </View>
          )}
        </ScrollView>

        {/* Input area */}
        <View
          style={tw`flex-row items-center border-t border-gray-200 px-4 py-2`}
        >
          <TextInput
            style={tw`flex-1 bg-gray-100 rounded-full px-4 py-2 mr-2`}
            placeholder="Type your message..."
            value={inputText}
            onChangeText={setInputText}
            multiline
          />
          <Pressable
            onPress={sendMessage}
            disabled={!inputText.trim() || isLoading}
            style={({ pressed }) => [
              tw`p-2 rounded-full`,
              {
                backgroundColor:
                  !inputText.trim() || isLoading ? "#94a3b8" : "#14b8a6",
                opacity: pressed ? 0.8 : 1,
              },
            ]}
          >
            <Ionicons name="send" size={22} color="white" />
          </Pressable>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}
