import React from "react";
import { render, fireEvent, waitFor, act } from "@testing-library/react-native";
import renderer from "react-test-renderer";
import Chatbot from "../chatbot";

// Mock dependencies
jest.mock("axios");
jest.mock("@/hooks/useAuth", () => {
  return {
    useAuth: jest.fn().mockImplementation(() => ({
      createApiInstance: jest.fn(),
      refreshToken: jest.fn(),
    })),
  };
});

jest.mock("@react-navigation/native", () => ({
  ...jest.requireActual("@react-navigation/native"),
  useNavigation: () => ({
    goBack: jest.fn(),
  }),
}));

jest.mock("react-native-root-toast", () => ({
  show: jest.fn(),
  durations: { SHORT: 2000 },
  positions: { BOTTOM: 50 },
}));

jest.mock("@expo/vector-icons", () => ({
  Ionicons: "Ionicons",
}));

// Don't mock the useRef hook - let it use the real implementation
jest.mock("react", () => {
  const actualReact = jest.requireActual("react");
  return {
    ...actualReact,
    // We'll keep the real useRef implementation
  };
});

// Access to the mocked useAuth function
const mockUseAuth = jest.requireMock("@/hooks/useAuth").useAuth;

describe("Chatbot Component", () => {
  beforeEach(() => {
    jest.clearAllMocks();

    // Setup API mocks
    const mockApi = {
      get: jest.fn(),
      post: jest.fn(),
    };

    mockApi.get.mockImplementation((url) => {
      if (url === "/user-exercises/") {
        return Promise.resolve({ data: [] });
      }
      if (url === "/reports/") {
        return Promise.resolve({ data: [] });
      }
      return Promise.reject(new Error("Unknown URL"));
    });

    mockApi.post.mockImplementation((url) => {
      if (url === "/api/chatbot/") {
        return Promise.resolve({
          data: { message: "Bot response" },
        });
      }
      if (url === "/api/reset-chat/") {
        return Promise.resolve({});
      }
      return Promise.reject(new Error("Unknown URL"));
    });

    // Update useAuth mock implementation
    mockUseAuth.mockImplementation(() => ({
      createApiInstance: jest.fn().mockResolvedValue(mockApi),
      refreshToken: jest.fn().mockResolvedValue("new-token"),
    }));
  });

  it("renders correctly with data", async () => {
    let tree: any;
    await act(async () => {
      tree = renderer.create(<Chatbot />);
    });

    // Allow any pending state updates and async operations to complete
    await new Promise((resolve) => setTimeout(resolve, 0));

    // Then call toJSON() outside of act
    const treeJSON = tree.toJSON();
    expect(treeJSON).not.toBeNull();
    expect(treeJSON).toMatchSnapshot();
  });

  it("renders initial messages and loading state", async () => {
    const { getByText, queryByTestId, findByText } = render(<Chatbot />);

    // Initially should show loading indicator
    expect(queryByTestId("activity-indicator")).toBeTruthy();

    // Wait for welcome message to appear - using findByText which has built-in waiting
    const welcomeMessage = await findByText(
      "Welcome to your physiotherapy assistant! How can I help you today?"
    );
    expect(welcomeMessage).toBeTruthy();

    // Verify DISCLAIMER is also shown
    expect(
      getByText(
        "DISCLAIMER: This feedback is generated by AI and is not a substitute for professional medical advice. Always consult with your healthcare provider before starting, changing, or stopping any exercise program."
      )
    ).toBeTruthy();

    // Now loading indicator should be gone
    expect(queryByTestId("activity-indicator")).toBeFalsy();
  });

  it("sends user message and displays bot response", async () => {
    const { getByPlaceholderText, getByTestId, getByText, findByText } = render(
      <Chatbot />
    );

    // Wait for the component to finish loading and show welcome message
    await findByText(
      "Welcome to your physiotherapy assistant! How can I help you today?"
    );

    // Type a message
    const input = getByPlaceholderText("Type your message...");
    fireEvent.changeText(input, "Hello bot");

    // Send the message
    const sendButton = getByTestId("send-button");
    fireEvent.press(sendButton);

    // Should show user message
    expect(getByText("Hello bot")).toBeTruthy();

    // Wait for bot response using findByText instead of manual waitFor
    const botResponse = await findByText("Bot response");
    expect(botResponse).toBeTruthy();
  });

  it("handles API errors when sending messages", async () => {
    // Mock API error
    const mockApi = {
      get: jest.fn().mockResolvedValue({ data: [] }),
      post: jest.fn().mockRejectedValue(new Error("API error")),
    };

    mockUseAuth.mockImplementation(() => ({
      createApiInstance: jest.fn().mockResolvedValue(mockApi),
      refreshToken: jest.fn().mockResolvedValue("new-token"),
    }));

    const { getByPlaceholderText, getByTestId, findByText } = render(
      <Chatbot />
    );

    // Wait for welcome message
    await findByText(
      "Welcome to your physiotherapy assistant! How can I help you today?"
    );

    // Type and send message
    const input = getByPlaceholderText("Type your message...");
    fireEvent.changeText(input, "This will fail");
    const sendButton = getByTestId("send-button");
    fireEvent.press(sendButton);

    // Wait for error message
    const errorMessage = await findByText(
      "Sorry, I encountered an error. Please try again."
    );
    expect(errorMessage).toBeTruthy();
  });

  it("resets chat history", async () => {
    // Set up the API mock to respond appropriately to reset
    const mockResetApi = jest.fn().mockResolvedValue({});

    const mockApi = {
      get: jest.fn().mockResolvedValue({ data: [] }),
      post: jest.fn().mockImplementation((url) => {
        if (url === "/api/chatbot/") {
          return Promise.resolve({ data: { message: "Bot response" } });
        }
        if (url === "/api/reset-chat/") {
          return mockResetApi();
        }
        return Promise.reject(new Error("Unknown URL"));
      }),
    };

    // Ensure we're using fresh mocks
    mockUseAuth.mockImplementation(() => ({
      createApiInstance: jest.fn().mockResolvedValue(mockApi),
      refreshToken: jest.fn().mockResolvedValue("new-token"),
    }));

    const { getByPlaceholderText, findByText, queryByText, getByTestId } =
      render(<Chatbot />);

    // Wait for welcome message
    await findByText(
      "Welcome to your physiotherapy assistant! How can I help you today?"
    );

    // Send a message and wait for response
    const input = getByPlaceholderText("Type your message...");
    fireEvent.changeText(input, "Test message");
    fireEvent.press(getByTestId("send-button"));
    await findByText("Bot response");

    // Now press reset
    fireEvent.press(getByTestId("reset-button"));

    // Verify the reset API was called
    await waitFor(() => expect(mockResetApi).toHaveBeenCalled());

    // Wait for reset to complete and component to re-render
    await findByText(
      "Welcome to your physiotherapy assistant! How can I help you today?"
    );

    // Test messages should be gone
    expect(queryByText("Test message")).toBeFalsy();
  });

  it("reset chat history fails", async () => {
    // Mock API error for reset but success for message
    const mockApi = {
      get: jest.fn().mockResolvedValue({ data: [] }),
      post: jest.fn().mockImplementation((url) => {
        if (url === "/api/chatbot/") {
          return Promise.resolve({
            data: { message: "Bot response" },
          });
        }
        if (url === "/api/reset-chat/") {
          return Promise.reject(new Error("Reset API error"));
        }
        return Promise.reject(new Error("Unknown URL"));
      }),
    };

    mockUseAuth.mockImplementation(() => ({
      createApiInstance: jest.fn().mockResolvedValue(mockApi),
      refreshToken: jest.fn().mockResolvedValue("new-token"),
    }));

    const { getByPlaceholderText, getByTestId, findByText } = render(
      <Chatbot />
    );

    // Wait for welcome message
    await findByText(
      "Welcome to your physiotherapy assistant! How can I help you today?"
    );

    // Type and send message
    const input = getByPlaceholderText("Type your message...");
    fireEvent.changeText(input, "Test message");
    const sendButton = getByTestId("send-button");
    fireEvent.press(sendButton);

    // Wait for bot response
    await findByText("Bot response");

    // Mock console.error to avoid test noise
    const originalConsoleError = console.error;
    console.error = jest.fn();

    try {
      // Press reset button
      const resetButton = getByTestId("reset-button");
      fireEvent.press(resetButton);

      // Wait for Alert to be called (we need to mock Alert separately)
      await waitFor(() => {
        expect(mockApi.post).toHaveBeenCalledWith("/api/reset-chat/", {});
      });
    } finally {
      // Restore console.error
      console.error = originalConsoleError;
    }
  });
});
